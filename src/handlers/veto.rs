//! # Veto and Match Preview Handlers
//!
//! This module implements endpoints for match preview and veto functionality.
//! Users can view their match previews, add/remove vetoes to exclude specific users
//! from matching, and retrieve their current veto list.
//!
//! # Match Preview System
//!
//! Match previews are pre-computed suggestions that users can view before final matching.
//! The system allows users to veto (exclude) specific suggestions they don't want to match with.
//!
//! # Veto System
//!
//! - Vetoes are bidirectional blocks preventing matches between users
//! - Users cannot veto themselves
//! - Veto operations are idempotent (adding existing veto returns existing record)
//! - All vetoes are cleared when final matching is triggered

use std::sync::Arc;

use axum::{
    Json,
    extract::{Extension, State},
    http::StatusCode,
    response::IntoResponse,
};
use sqlx::PgPool;
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

use crate::error::{AppError, AppResult};
use crate::middleware::AuthUser;
use crate::models::{AppState, ProfilePreview, Veto, VetoRequest};

/// Gets match previews for the authenticated user.
///
/// GET /api/veto/previews
///
/// This endpoint returns pre-computed match suggestions for users who have completed
/// their forms. Match previews are generated by the matching algorithm and updated
/// periodically by administrators.
///
/// # Returns
///
/// - `200 OK` with `Vec<ProfilePreview>` - Match previews retrieved successfully
/// - `401 Unauthorized` - Missing or invalid authentication token
/// - `500 Internal Server Error` - Database error
#[instrument(
    skip_all,
    fields(
        user_id = %user.user_id,
        request_id = %uuid::Uuid::new_v4()
    )
)]
pub async fn get_previews(
    State(state): State<Arc<AppState>>,
    Extension(user): Extension<AuthUser>,
) -> AppResult<Json<Vec<ProfilePreview>>> {
    debug!("Fetching match previews for user");

    let profiles = fetch_profile_previews(&state.db_pool, user.user_id).await?;
    info!("Found {} match previews for user", profiles.len());

    Ok(Json(profiles))
}

/// Adds a veto for a specific user.
///
/// POST /api/veto VetoRequest
///
/// This endpoint allows users to veto (exclude) specific users from being matched
/// with them. The operation is idempotent - if a veto already exists, the existing
/// veto record is returned. Users cannot veto themselves.
///
/// # Returns
///
/// - `201 Created` with `Veto` - New veto created successfully
/// - `200 OK` with `Veto` - Veto already exists (idempotent response)
/// - `400 Bad Request` - Invalid request or attempt to self-veto
/// - `401 Unauthorized` - Missing or invalid authentication token
/// - `500 Internal Server Error` - Database error
#[instrument(
    skip_all,
    fields(
        user_id = %user.user_id,
        target_id = %request.vetoed_id,
        request_id = %uuid::Uuid::new_v4()
    )
)]
pub async fn add_veto(
    State(state): State<Arc<AppState>>,
    Extension(user): Extension<AuthUser>,
    Json(request): Json<VetoRequest>,
) -> AppResult<(StatusCode, Json<Veto>)> {
    debug!("Processing add veto request");
    let vetoer_id = user.user_id;
    let vetoed_id = request.vetoed_id;

    // Prevent self-vetoing
    if vetoer_id == vetoed_id {
        warn!("User attempted to veto themselves");
        return Err(AppError::BadRequest("Cannot veto yourself"));
    }

    match create_veto(&state.db_pool, vetoer_id, vetoed_id).await {
        Ok(veto) => {
            info!("User successfully vetoed target user");
            Ok((StatusCode::CREATED, Json(veto)))
        }
        Err(e) => {
            if e.to_string().contains("duplicate key") {
                debug!("User already vetoed target user");
                // Fetch existing veto record for idempotent response
                let existing_veto = fetch_veto(&state.db_pool, vetoer_id, vetoed_id).await?;
                Ok((StatusCode::OK, Json(existing_veto)))
            } else {
                error!("Failed to create veto: {}", e);
                Err(AppError::Internal)
            }
        }
    }
}

/// Removes a veto for a specific user.
///
/// DELETE /api/veto VetoRequest
///
/// This endpoint allows users to remove an existing veto, allowing the previously
/// vetoed user to potentially be matched again. If no veto exists between the users,
/// returns 404 Not Found.
///
/// # Returns
///
/// - `200 OK` with `Veto` - Veto removed successfully
/// - `404 Not Found` - No veto exists between users
/// - `401 Unauthorized` - Missing or invalid authentication token
/// - `500 Internal Server Error` - Database error
#[instrument(
    skip_all,
    fields(
        user_id = %user.user_id,
        target_id = %request.vetoed_id,
        request_id = %uuid::Uuid::new_v4()
    )
)]
pub async fn remove_veto(
    State(state): State<Arc<AppState>>,
    Extension(user): Extension<AuthUser>,
    Json(request): Json<VetoRequest>,
) -> AppResult<impl IntoResponse> {
    debug!("Processing remove veto request");
    let vetoer_id = user.user_id;
    let vetoed_id = request.vetoed_id;

    // Fetch the veto record first (before deleting) to return it
    let veto_to_delete = fetch_veto(&state.db_pool, vetoer_id, vetoed_id).await.ok();

    let rows_affected = delete_veto(&state.db_pool, vetoer_id, vetoed_id).await?;
    if rows_affected > 0
        && let Some(veto) = veto_to_delete
    {
        info!("User successfully removed veto for target user");
        Ok((StatusCode::OK, Json(veto)).into_response())
    } else {
        debug!("No veto found to remove between user and target");
        Ok(StatusCode::NOT_FOUND.into_response())
    }
}

/// Gets all vetoes for the authenticated user.
///
/// GET /api/veto
///
/// This endpoint returns a list of user IDs that the authenticated user has vetoed.
/// The response contains only the UUIDs of vetoed users, not their full profiles.
///
/// # Returns
///
/// - `200 OK` with `Vec<Uuid>` - List of vetoed user IDs retrieved successfully
/// - `401 Unauthorized` - Missing or invalid authentication token
/// - `500 Internal Server Error` - Database error
#[instrument(
    skip_all,
    fields(
        user_id = %user.user_id,
        request_id = %uuid::Uuid::new_v4()
    )
)]
pub async fn get_vetoes(
    State(state): State<Arc<AppState>>,
    Extension(user): Extension<AuthUser>,
) -> AppResult<Json<Vec<Uuid>>> {
    debug!("Fetching vetoes for user");

    let vetoes = fetch_user_vetoes(&state.db_pool, user.user_id).await?;
    let vetoed_ids: Vec<Uuid> = vetoes.into_iter().map(|v| v.vetoed_id).collect();
    info!("Found {} vetoes for user", vetoed_ids.len());

    Ok(Json(vetoed_ids))
}

// --- Database helper functions ---

async fn create_veto(
    db_pool: &PgPool,
    vetoer_id: Uuid,
    vetoed_id: Uuid,
) -> Result<Veto, sqlx::Error> {
    sqlx::query_as!(
        Veto,
        "INSERT INTO vetoes (vetoer_id, vetoed_id) VALUES ($1, $2)
         RETURNING id, vetoer_id, vetoed_id",
        vetoer_id,
        vetoed_id
    )
    .fetch_one(db_pool)
    .await
}

async fn delete_veto(
    db_pool: &PgPool,
    vetoer_id: Uuid,
    vetoed_id: Uuid,
) -> Result<u64, sqlx::Error> {
    let result = sqlx::query!(
        "DELETE FROM vetoes WHERE vetoer_id = $1 AND vetoed_id = $2",
        vetoer_id,
        vetoed_id
    )
    .execute(db_pool)
    .await?;

    Ok(result.rows_affected())
}

async fn fetch_veto(
    db_pool: &PgPool,
    vetoer_id: Uuid,
    vetoed_id: Uuid,
) -> Result<Veto, sqlx::Error> {
    sqlx::query_as!(
        Veto,
        "SELECT id, vetoer_id, vetoed_id FROM vetoes WHERE vetoer_id = $1 AND vetoed_id = $2",
        vetoer_id,
        vetoed_id
    )
    .fetch_one(db_pool)
    .await
}

async fn fetch_user_vetoes(db_pool: &PgPool, user_id: Uuid) -> Result<Vec<Veto>, sqlx::Error> {
    sqlx::query_as!(
        Veto,
        "SELECT id, vetoer_id, vetoed_id FROM vetoes WHERE vetoer_id = $1",
        user_id
    )
    .fetch_all(db_pool)
    .await
}

async fn fetch_profile_previews(
    db_pool: &PgPool,
    user_id: Uuid,
) -> Result<Vec<ProfilePreview>, sqlx::Error> {
    let result = sqlx::query!(
        r#"
        SELECT
            f.familiar_tags,
            f.aspirational_tags,
            f.recent_topics,
            u.email,
            u.grade
        FROM match_previews mp
        JOIN forms f ON f.user_id = ANY(mp.candidate_ids)
        JOIN users u ON u.id = f.user_id
        WHERE mp.user_id = $1
        "#,
        user_id
    )
    .fetch_all(db_pool)
    .await?;

    let profiles = result
        .into_iter()
        .map(|row| {
            let email_domain = row.email.split('@').nth(1).unwrap_or("").to_string();
            ProfilePreview {
                familiar_tags: row.familiar_tags,
                aspirational_tags: row.aspirational_tags,
                recent_topics: row.recent_topics,
                email_domain,
                grade: row.grade,
            }
        })
        .collect();

    Ok(profiles)
}
